/* jshint -W097 */// jshint strict:false
/* jslint node:true */
/* jshint node:true */

'use strict';

var adapterName = require(__dirname + '/package.json').name.split('.').pop();
var express = require('express');
var socketio = require('socket.io');
var request = require('request');
var fs = require('fs');
var Stream = require('stream');
var webPush = require('web-push');
var utils = require(__dirname + '/lib/utils'); // Get common adapter utils
var tools = require(utils.controllerDir + '/lib/tools.js');
var LE = require(utils.controllerDir + '/lib/letsencrypt.js');

var session;
var cookieParser;
var bodyParser;
var AdapterStore;
var passportSocketIo;
var password;
var passport;
var LocalStrategy;
var flash;

var webServer = null;
var store = null;
var objects = {};
var states = {};
var secret = 'Zgfr56gFe87jJOM'; // Will be generated by first start
var userKey = 'connect.sid';
var cmdSessions = {};
var bruteForce = {};
var subscriptions = [];

// do not send too many state updates
var eventsThreshold = {
    count: 0,
    timeActivated: 0,
    active: false,
    accidents: 0,
    repeatSeconds: 3, // how many seconds continuously must be number of events > value
    value: 200, // how many events allowed in one check interval
    checkInterval: 1000 // duration of one check interval
};

// ServiceWorker for desktop messages
if (process.env.GCM_API_KEY) {
    webPush.setGCMAPIKey(process.env.GCM_API_KEY);
}

function sendNotification(endpoint, msg) {
    webPush.sendNotification({
        endpoint: endpoint
    }, msg).catch(function () {
        subscriptions.splice(subscriptions.indexOf(endpoint), 1);
    });
}

function isSubscribed(endpoint) {
    return (subscriptions.indexOf(endpoint) >= 0);
}

// END ServiceWorker for desktop messages

var adapter = new utils.Adapter({
    name: adapterName, // adapter name
    dirname: __dirname, // say own position
    logTransporter: true, // receive the logs
    install: function (callback) {
        if (typeof callback === 'function') {
            callback();
        }
    }
});

adapter.on('objectChange', function (id, obj) {
    if (obj) {
        //console.log('objectChange: ' + id);
        objects[id] = obj;

        if (id === 'system.repositories') {
            writeUpdateInfo();
        }
    } else {
        //console.log('objectDeleted: ' + id);
        if (objects[id]) {
            delete objects[id];
        }
    }
    // TODO Build in some threshold of messages

    if (webServer && webServer.io) {
        var clients = webServer.io.sockets.connected;

        for (var i in clients) {
            updateSession(clients[i]);
        }
        webServer.io.sockets.emit('objectChange', id, obj);
    }
});

// detect event bursts
setInterval(function () {
    if (!eventsThreshold.active) {
        if (eventsThreshold.count > eventsThreshold.value) {
            eventsThreshold.accidents++;

            if (eventsThreshold.accidents >= eventsThreshold.repeatSeconds) {
                enableEventThreshold();
            }
        } else {
            eventsThreshold.accidents = 0;
        }
        eventsThreshold.count = 0;
    } else if (new Date().getTime() - eventsThreshold.timeActivated > 60000) {
        disableEventThreshold();
    }
}, eventsThreshold.checkInterval);

adapter.on('stateChange', function (id, state) {
    if (!state) {
        if (states[id]) {
            delete states[id];
        }
    } else {
        states[id] = state;
    }
    if (webServer && webServer.io) {
        var clients = webServer.io.sockets.connected;

        if (!eventsThreshold.active) {
            eventsThreshold.count++;
        }
        for (var i in clients) {
            if (clients.hasOwnProperty(i)) {
                updateSession(clients[i]);
            }
        }
        webServer.io.sockets.emit('stateChange', id, state);
    }
});

adapter.on('ready', function () {
    adapter.getForeignObject('system.config', function (err, obj) {
        if (!err && obj) {
            obj.native = obj.native || {};
            if (!obj.native.secret) {
                require('crypto').randomBytes(24, function (ex, buf) {
                    secret = buf.toString('hex');
                    adapter.extendForeignObject('system.config', {native: {secret: secret}});
                    main();
                });
            } else {
                secret = obj.native.secret;
                main();
            }
        } else {
            adapter.logger.error('Cannot find object system.config');
        }
    });
});

adapter.on('message', function (obj) {
    if (!obj || !obj.message)
        return false;

    if (cmdSessions[obj.message.id]) {
        if (webServer) {
            webServer.io.sockets.emit(obj.command, obj.message.id, obj.message.data);
        }
        // we cannot save the socket, because if it takes a bit time, the socket will be invalid
        //cmdSessions[obj.message.id].socket.emit(obj.command, obj.message.id, obj.message.data);
        if (obj.command === 'cmdExit') {
            delete cmdSessions[obj.message.id];
        }
    }

    return true;
});

adapter.on('unload', function (callback) {
    if (adapter.requireLog) {
        adapter.requireLog(false);
    }

    try {
        adapter.log.info('terminating http' + (webServer.settings.secure ? 's' : '') + ' server on port ' + webServer.settings.port);
        webServer.server.close();

        callback();
    } catch (e) {
        callback();
    }
});

adapter.on('log', function (obj) {
    // obj = {message: msg, severity: level, from: this.namespace, ts: (new Date()).getTime()}
    if (obj.severity === "error") {
        for (var endpoint in subscriptions) {
            sendNotification(endpoint, obj.message);
        }
    }
    if (webServer && webServer.io && webServer.io.sockets) {
        // TODO Build in some threshold
        webServer.io.sockets.emit('log', obj);
    }
});

function createUpdateInfo() {
    // create connected object and state
    var obj = objects[adapter.namespace + '.info.updatesNumber'];

    if (!obj || !obj.common || obj.common.type !== 'number') {
        obj = {
            _id: 'info.updatesNumber',
            type: 'state',
            common: {
                role: 'indicator.updates',
                name: 'Number of adapters to update',
                type: 'number',
                read: true,
                write: false,
                def: 0
            },
            native: {}
        };

        adapter.setObject(obj._id, obj);
    }
    obj = objects[adapter.namespace + '.info.updatesList'];
    if (!obj || !obj.common || obj.common.type !== 'string') {
        obj = {
            _id: 'info.updatesList',
            type: 'state',
            common: {
                role: 'indicator.updates',
                name: 'List of adapters to update',
                type: 'string',
                read: true,
                write: false,
                def: ''
            },
            native: {}
        };

        adapter.setObject(obj._id, obj);
    }
}

// Helper methods
function upToDate(a, b) {
    a = a.split('.');
    b = b.split('.');
    a[0] = parseInt(a[0], 10);
    b[0] = parseInt(b[0], 10);
    if (a[0] > b[0]) {
        return false;
    } else if (a[0] < b[0]) {
        return true;
    } else if (a[0] === b[0]) {
        a[1] = parseInt(a[1], 10);
        b[1] = parseInt(b[1], 10);
        if (a[1] > b[1]) {
            return false;
        } else if (a[1] < b[1]) {
            return true;
        } else if (a[1] === b[1]) {
            a[2] = parseInt(a[2], 10);
            b[2] = parseInt(b[2], 10);
            return a[2] <= b[2];
        }
    } else {
        return true;
    }
}

function writeUpdateInfo(sources) {
    if (!sources) {
        var obj = objects['system.repositories'];
        if (!objects['system.config'].common) {
            adapter.log.warn('Repository cannot be read. Invalid "system.config" object.');
            return;
        }

        var activeRepo = objects['system.config'].common.activeRepo;

        if (obj && obj.native && obj.native.repositories && obj.native.repositories[activeRepo] &&
                obj.native.repositories[activeRepo].json) {
            sources = obj.native.repositories[activeRepo].json;
        } else {
            adapter.setState('info.updatesNumber', 0, true);
            adapter.setState('info.updatesList', '', true);
            if (obj && obj.native && obj.native.repositories && obj.native.repositories[activeRepo]) {
                adapter.log.warn('Repository cannot be read');
            } else {
                adapter.log.warn('No repository source configured');
            }
            return;
        }
    }

    var installed = tools.getInstalledInfo();
    var list = [];

    for (var name in sources) {
        if (installed[name] && installed[name].version && sources[name].version) {
            if (sources[name].version !== installed[name].version &&
                    !upToDate(sources[name].version, installed[name].version)) {
                // remove first part of the name
                var n = name.indexOf('.');
                list.push(n === -1 ? name : name.substring(n + 1));
            }
        }
    }
    adapter.setState('info.updatesNumber', list.length, true);
    adapter.setState('info.updatesList', list.join(', '), true);
}

// to do => remove it later, when all repositories patched.
function patchRepos(callback) {
    adapter.getForeignObject('system.repositories', function (err, obj) {
        if (err) {
            console.log(err);
        }
        var changed = false;
        if (obj && obj.native && obj.native.repositories) {
            // default link should point to stable
            if (!obj.native.repositories.default || obj.native.repositories.default.link !== 'http://download.iobroker.net/sources-dist.json') {
                changed = true;
                obj.native.repositories.default = {
                    link: 'http://download.iobroker.net/sources-dist.json'
                };
            }
            // latest link should point to latest
            if (!obj.native.repositories.latest) {
                obj.native.repositories.latest = {
                    link: 'http://download.iobroker.net/sources-dist-latest.json'
                };
                changed = true;
            }

            // change URL of raw sources from ioBroker.js-controller to ioBroker.repositories
            for (var r in obj.native.repositories) {
                if (obj.native.repositories.hasOwnProperty(r) &&
                        obj.native.repositories[r].link === 'https://raw.githubusercontent.com/ioBroker/ioBroker.js-controller/master/conf/sources-dist.json') {
                    obj.native.repositories[r].link = 'https://raw.githubusercontent.com/ioBroker/ioBroker.repositories/master/sources-dist.json';
                    changed = true;
                }
            }
        }
        if (changed) {
            adapter.setForeignObject(obj._id, obj, function () {
                callback && callback();
            });
        } else {
            callback && callback();
        }
    });
}

function main() {
    adapter.subscribeForeignStates('*');
    adapter.subscribeForeignObjects('*');

    adapter.config.defaultUser = adapter.config.defaultUser || 'admin';
    if (!adapter.config.defaultUser.match(/^system\.user\./)) {
        adapter.config.defaultUser = 'system.user.' + adapter.config.defaultUser;
    }

    if (adapter.config.secure) {
        // Load certificates
        adapter.getCertificates(function (err, certificates, leConfig) {
            if (err) {
                console.log(err);
            }
            adapter.config.certificates = certificates;
            adapter.config.leConfig = leConfig;
            webServer = initWebServer(adapter.config);
            getData();
        });
    } else {
        webServer = initWebServer(adapter.config);
        getData();
    }

    patchRepos(function () {
        // By default update repository every 24 hours
        if (adapter.config.autoUpdate === undefined) {
            adapter.config.autoUpdate = 24;
        }
        adapter.config.autoUpdate = parseInt(adapter.config.autoUpdate, 10) || 0;
        if (adapter.config.autoUpdate) {
            setInterval(function () {
                updateRegister();
            }, adapter.config.autoUpdate * 3600000);
            updateRegister();
        }
    });

}

function addUser(user, pw, options, callback) {
    adapter.getForeignObject('system.user.' + user, options, function (err, obj) {
        if (err) {
            console.log(err);
        }
        if (obj) {
            if (typeof callback === 'function') {
                callback('User yet exists');
            }
        } else {
            adapter.setForeignObject('system.user.' + user, {
                type: 'user',
                common: {
                    name: user,
                    enabled: true,
                    groups: []
                }
            }, options, function () {
                adapter.setPassword(user, pw, callback);
            });
        }
    });
}

function delUser(user, options, callback) {
    adapter.getForeignObject('system.user.' + user, options, function (err, obj) {
        if (err || !obj) {
            if (callback) {
                callback('User does not exist');
            }
        } else {
            if (obj.common.dontDelete) {
                if (callback) {
                    callback('Cannot delete user, while is system user');
                }
            } else {
                adapter.delForeignObject('system.user.' + user, options, function (err) {
                    // Remove this user from all groups in web client
                    if (callback) {
                        callback(err);
                    }
                });
            }
        }
    });
}

function addGroup(group, desc, acl, options, callback) {
    var name = group;
    if (typeof acl === 'function') {
        callback = acl;
        acl = null;
    }
    if (typeof desc === 'function') {
        callback = desc;
        desc = null;
    }
    if (typeof options === 'function') {
        callback = options;
        options = null;
    }
    if (name && name.substring(0, 1) !== name.substring(0, 1).toUpperCase()) {
        name = name.substring(0, 1).toUpperCase() + name.substring(1);
    }
    group = group.substring(0, 1).toLowerCase() + group.substring(1);

    adapter.getForeignObject('system.group.' + group, options, function (err, obj) {
        if (err) {
            console.log(err);
        }
        if (obj) {
            if (callback) {
                callback('Group yet exists');
            }
        } else {
            adapter.setForeignObject('system.group.' + group, {
                type: 'group',
                common: {
                    name: name,
                    desc: desc,
                    members: [],
                    acl: acl
                }
            }, options, function (err, obj) {
                if (callback) {
                    callback(err, obj);
                }
            });
        }
    });
}

function delGroup(group, options, callback) {
    adapter.getForeignObject('system.group.' + group, options, function (err, obj) {
        if (err || !obj) {
            if (callback) {
                callback('Group does not exist');
            }
        } else {
            if (obj.common.dontDelete) {
                if (callback) {
                    callback('Cannot delete group, while is system group');
                }
            } else {
                adapter.delForeignObject('system.group.' + group, options, function (err) {
                    // Remove this group from all users in web client
                    if (callback) {
                        callback(err);
                    }
                });
            }
        }
    });
}

//settings: {
//    "port":   8080,
//    "auth":   false,
//    "secure": false,
//    "bind":   "0.0.0.0", // "::"
//    "cache":  false
//}
function initWebServer(settings) {

    var server = {
        app: null,
        server: null,
        io: null,
        settings: settings
    };

    if (settings.port) {
        server.app = express();
        if (settings.auth) {
            session = require('express-session');
            cookieParser = require('cookie-parser');
            bodyParser = require('body-parser');
            AdapterStore = require(utils.controllerDir + '/lib/session.js')(session, adapter.config.ttl);
            passportSocketIo = require('passport.socketio');
            password = require(utils.controllerDir + '/lib/password.js');
            passport = require('passport');
            LocalStrategy = require('passport-local').Strategy;
            flash = require('connect-flash'); // TODO report error to user

            store = new AdapterStore({adapter: adapter});

            passport.use(new LocalStrategy(
                    function (username, password, done) {
                        if (bruteForce[username] && bruteForce[username].errors > 4) {
                            var minutes = (new Date().getTime() - bruteForce[username].time);
                            if (bruteForce[username].errors < 7) {
                                if ((new Date().getTime() - bruteForce[username].time) < 60000) {
                                    minutes = 1;
                                } else {
                                    minutes = 0;
                                }
                            } else
                            if (bruteForce[username].errors < 10) {
                                if ((new Date().getTime() - bruteForce[username].time) < 180000) {
                                    minutes = Math.ceil((180000 - minutes) / 60000);
                                } else {
                                    minutes = 0;
                                }
                            } else
                            if (bruteForce[username].errors < 15) {
                                if ((new Date().getTime() - bruteForce[username].time) < 600000) {
                                    minutes = Math.ceil((600000 - minutes) / 60000);
                                } else {
                                    minutes = 0;
                                }
                            } else
                            if ((new Date().getTime() - bruteForce[username].time) < 3600000) {
                                minutes = Math.ceil((3600000 - minutes) / 60000);
                            } else {
                                minutes = 0;
                            }

                            if (minutes) {
                                return done('Too many errors. Try again in ' + minutes + ' ' + (minutes === 1 ? 'minute' : 'minutes') + '.', false);
                            }
                        }
                        adapter.checkPassword(username, password, function (res) {
                            if (!res) {
                                bruteForce[username] = bruteForce[username] || {errors: 0};
                                bruteForce[username].time = new Date().getTime();
                                bruteForce[username].errors++;
                            } else if (bruteForce[username]) {
                                delete bruteForce[username];
                            }

                            if (res) {
                                return done(null, username);
                            } else {
                                return done(null, false);
                            }
                        });

                    }
            ));
            passport.serializeUser(function (user, done) {
                done(null, user);
            });

            passport.deserializeUser(function (user, done) {
                done(null, user);
            });

            server.app.use(cookieParser());
            server.app.use(bodyParser.urlencoded({
                extended: true
            }));
            server.app.use(bodyParser.json());
            server.app.use(session({
                secret: secret,
                saveUninitialized: true,
                resave: true,
                store: store
            }));
            server.app.use(passport.initialize());
            server.app.use(passport.session());
            server.app.use(flash());

            server.app.post('/login', function (req, res, next) {
                var redirect = '/';
                if (req.body.origin) {
                    var parts = req.body.origin.split('=');
                    if (parts[1]) {
                        redirect = decodeURIComponent(parts[1]);
                    }
                }
                var authenticate = passport.authenticate('local', {
                    successRedirect: redirect,
                    failureRedirect: '/login/index.html' + req.body.origin + (req.body.origin ? '&error' : '?error'),
                    failureFlash: 'Invalid username or password.'
                })(req, res, next);
            });

            server.app.get('/logout', function (req, res) {
                req.logout();
                res.redirect('/login/index.html');
            });

            // route middleware to make sure a user is logged in
            server.app.use(function (req, res, next) {
                if (req.isAuthenticated() ||
                        /^\/login\//.test(req.originalUrl) ||
                        /\.ico$/.test(req.originalUrl)) {
                    return next();
                }
                res.redirect('/login/index.html?href=' + encodeURIComponent(req.originalUrl));
            });


        } else {
            server.app.get('/login', function (req, res) {
                res.redirect('/');
            });
            server.app.get('/logout', function (req, res) {
                res.redirect('/');
            });
        }

        var appOptions = {};
        if (settings.cache) {
            appOptions.maxAge = 30758400000;
        }

        server.app.use('/', express.static(__dirname + '/www', appOptions));

        // reverse proxy with url rewrite for couchdb attachments in <adapter-name>.admin
        server.app.use('/adapter/', function (req, res) {

            // Example: /example/?0
            var url = req.url;

            // add index.html
            url = url.replace(/\/($|\?|#)/, '/index.html$1');

            // Read config files for admin from /adapters/admin/admin/...
            if (url.substring(0, '/' + adapter.name + '/'.length) === '/' + adapter.name + '/') {
                url = url.replace('/' + adapter.name + '/', __dirname + '/admin/');
                url = url.replace(/\?[0-9]*/, '');

                try {
                    if (fs.existsSync(url)) {
                        fs.createReadStream(url).pipe(res);
                    } else {
                        var ss = new Stream();
                        ss.pipe = function (dest) {
                            dest.write('File not found');
                        };

                        ss.pipe(res);
                    }
                } catch (e) {
                    var s = new Stream();
                    s.pipe = function (dest) {
                        dest.write('File not found: ' + e);
                    };

                    s.pipe(res);
                }
                return;
            }
            url = url.split('/');
            // Skip first /
            url.shift();
            // Get ID
            var id = url.shift() + '.admin';
            url = url.join('/');
            var pos = url.indexOf('?');
            if (pos != -1) {
                url = url.substring(0, pos);
            }
            adapter.readFile(id, url, null, function (err, buffer, mimeType) {
                if (!buffer || err) {
                    res.contentType('text/html');
                    res.status(404).send('File ' + url + ' not found');
                } else {
                    if (mimeType) {
                        res.contentType(mimeType['content-type'] || mimeType);
                    } else {
                        res.contentType('text/javascript');
                    }
                    res.send(buffer);
                }
            });
        });

        server.server = LE.createServer(server.app, settings, adapter.config.certificates, adapter.config.leConfig, adapter.log);
        server.server.__server = server;
    } else {
        adapter.log.error('port missing');
        process.exit(1);
    }

    if (server.server) {
        adapter.getPort(settings.port, function (port) {
            if (port !== settings.port && !adapter.config.findNextPort) {
                adapter.log.error('port ' + settings.port + ' already in use');
                process.exit(1);
            }
            server.server.listen(port);
            adapter.log.info('http' + (settings.secure ? 's' : '') + ' server listening on port ' + port);
            adapter.log.info('Use link "http' + (settings.secure ? 's' : '') + '://localhost:' + port + '" to configure.');

            server.io = socketio.listen(server.server, (settings.bind && settings.bind !== "0.0.0.0") ? settings.bind : undefined);

            if (settings.auth) {
                server.io.use(passportSocketIo.authorize({
                    passport: passport,
                    cookieParser: cookieParser,
                    key: userKey, // the name of the cookie where express/connect stores its session_id
                    secret: secret, // the session_secret to parse the cookie
                    store: store, // we NEED to use a sessionstore. no memorystore please
                    success: onAuthorizeSuccess, // *optional* callback on success - read more below
                    fail: onAuthorizeFail      // *optional* callback on fail/error - read more below
                }));
            }

            /*server.io.set('logger', {
             debug: function(obj) {adapter.log.debug('socket.io: ' + obj)},
             info:  function(obj) {adapter.log.debug('socket.io: ' + obj)} ,
             error: function(obj) {adapter.log.error('socket.io: ' + obj)},
             warn:  function(obj) {adapter.log.warn('socket.io: ' + obj)}
             });*/
            server.io.on('connection', initSocket);
        });
    }

    server.app.post('/register', function (req, res) {
        var endpoint = req.endpoint;
        if (!isSubscribed(endpoint)) {
            subscriptions.push(endpoint);
        }
        res.type('js').send('{"success":true}');
    });

    server.app.post('/unregister', function (req, res) {
        var endpoint = req.endpoint;
        if (isSubscribed(endpoint)) {
            subscriptions.splice(subscriptions.indexOf(endpoint), 1);
        }
        res.type('js').send('{"success":true}');
    });

    if (server.server) {
        return server;
    } else {
        return null;
    }
}

function getData() {
    adapter.log.info('requesting all states');
    adapter.getForeignStates('*', function (err, res) {
        if (err) {
            console.log(err);
        }
        adapter.log.info('received all states');
        states = res;
    });
    adapter.log.info('requesting all objects');
    adapter.objects.getObjectList({include_docs: true}, function (err, res) {
        if (err) {
            console.log(err);
        }
        adapter.log.info('received all objects');
        res = res.rows;
        objects = {};
        for (var i = 0; i < res.length; i++) {
            objects[res[i].doc._id] = res[i].doc;
        }
        createUpdateInfo();
        writeUpdateInfo();
    });
}

// Extract user name from socket
function getUserFromSocket(socket, callback) {
    var wait = false;
    try {
        if (socket.conn.request.sessionID) {
            wait = true;
            store.get(socket.conn.request.sessionID, function (err, obj) {
                if (err) {
                    console.log(err);
                }
                if (obj && obj.passport && obj.passport.user) {
                    if (callback) {
                        callback(null, obj.passport.user ? 'system.user.' + obj.passport.user : '');
                    }
                    return;
                }
            });
        }
    } catch (e) {

    }
    if (!wait && callback) {
        callback('Cannot detect user');
    }
}

function disableEventThreshold(readAll) {
    if (eventsThreshold.active) {
        eventsThreshold.accidents = 0;
        eventsThreshold.count = 0;
        eventsThreshold.active = false;
        eventsThreshold.timeActivated = 0;
        adapter.log.info('Subscribe on all states again');

        setTimeout(function () {
            if (readAll) {
                adapter.getForeignStates('*', function (err, res) {
                    if (err) {
                        console.log(err);
                    }
                    adapter.log.info('received all states');
                    for (var id in res) {
                        if (res.hasOwnProperty(id) && JSON.stringify(states[id]) !== JSON.stringify(res[id])) {
                            webServer.io.sockets.emit('stateChange', id, res[id]);
                            states[id] = res[id];
                        }
                    }
                });
            }

            webServer.io.sockets.emit('eventsThreshold', false);
            adapter.unsubscribeForeignStates('system.adapter.*');
            adapter.subscribeForeignStates('*');

        }, 50);

    }
}

function enableEventThreshold() {
    if (!eventsThreshold.active) {
        eventsThreshold.active = true;

        setTimeout(function () {
            adapter.log.info('Unsubscribe from all states, except system\'s, because over ' + eventsThreshold.repeatSeconds + ' seconds the number of events is over ' + eventsThreshold.value + ' (in last second ' + eventsThreshold.count + ')');
            eventsThreshold.timeActivated = new Date().getTime();

            webServer.io.sockets.emit('eventsThreshold', true);
            adapter.unsubscribeForeignStates('*');
            adapter.subscribeForeignStates('system.adapter.*');
        }, 100);
    }
}

function initSocket(socket) {
    disableEventThreshold();

    if (adapter.config.auth) {
        adapter.config.ttl = parseInt(adapter.config.ttl, 10) || 3600;
        getUserFromSocket(socket, function (err, user) {
            if (err || !user) {
                adapter.log.error('socket.io ' + err);
            } else {
                adapter.log.debug('socket.io client ' + user + ' connected');
                adapter.calculatePermissions(user, commandsPermissions, function (acl) {
                    socket._acl = acl;
                    socketEvents(socket);
                });
            }
        });
    } else {
        adapter.calculatePermissions(adapter.config.defaultUser || 'system.user.admin', commandsPermissions, function (acl) {
            socket._acl = acl;
            socketEvents(socket);
        });
    }
}

// update session ID, but not ofter than 60 seconds
function updateSession(socket) {
    if (socket._sessionID) {
        var time = (new Date()).getTime();
        if (socket._lastActivity && time - socket._lastActivity > adapter.config.ttl * 1000) {
            socket.emit('reauthenticate');
            return false;
        }
        socket._lastActivity = time;
        if (!socket._sessionTimer) {
            socket._sessionTimer = setTimeout(function () {
                socket._sessionTimer = null;
                adapter.getSession(socket._sessionID, function (obj) {
                    if (obj) {
                        adapter.setSession(socket._sessionID, adapter.config.ttl, obj);
                    } else {
                        socket.emit('reauthenticate');
                    }
                });
            }, 60000);
        }
    }
    return true;
}

function checkPermissions(socket, command, callback, arg) {
    if (socket._acl.user !== 'system.user.admin') {
        // type: file, object, state, other
        // operation: create, read, write, list, delete, sendto, execute, sendto
        if (commandsPermissions[command]) {
            // If permission required
            if (commandsPermissions[command].type) {
                if (socket._acl[commandsPermissions[command].type] &&
                        socket._acl[commandsPermissions[command].type][commandsPermissions[command].operation]) {
                    return true;
                } else {
                    adapter.log.warn('No permission for "' + socket._acl.user + '" to call ' + command + '. Need "' + commandsPermissions[command].type + '"."' + commandsPermissions[command].operation + '"');
                }
            } else {
                return true;
            }
        } else {
            adapter.log.warn('No rule for command: ' + command);
        }

        if (callback) {
            callback('permissionError');
        } else {
            socket.emit('permissionError', {
                command: command,
                type: commandsPermissions[command].type,
                operation: commandsPermissions[command].operation,
                arg: arg
            });
        }
        return false;
    } else {
        return true;
    }
}

function checkObject(id, options, flag) {
    // read rights of object
    if (!objects[id] || !objects[id].common || !objects[id].acl || flag === 'list') {
        return true;
    }

    if (options.user !== 'system.user.admin' &&
            options.groups.indexOf('system.group.administrator') === -1) {
        if (objects[id].acl.owner !== options.user) {
            // Check if the user is in the group
            if (options.groups.indexOf(objects[id].acl.ownerGroup) !== -1) {
                // Check group rights
                if (!(objects[id].acl.object & (flag << 4))) {
                    return false;
                }
            } else {
                // everybody
                if (!(objects[id].acl.object & flag)) {
                    return false;
                }
            }
        } else {
            // Check group rights
            if (!(objects[id].acl.object & (flag << 8))) {
                return false;
            }
        }
    }
    return true;
}

// static information
var commandsPermissions = {
    getObject: {type: 'object', operation: 'read'},
    getObjects: {type: 'object', operation: 'list'},
    getObjectView: {type: 'object', operation: 'list'},
    setObject: {type: 'object', operation: 'write'},
    delObject: {type: 'object', operation: 'delete'},
    extendObject: {type: 'object', operation: 'write'},
    getHostByIp: {type: 'object', operation: 'list'},
    getStates: {type: 'state', operation: 'list'},
    getState: {type: 'state', operation: 'read'},
    setState: {type: 'state', operation: 'write'},
    delState: {type: 'state', operation: 'delete'},
    getStateHistory: {type: 'state', operation: 'read'},
    createState: {type: 'state', operation: 'create'},
    addUser: {type: 'users', operation: 'create'},
    delUser: {type: 'users', operation: 'delete'},
    addGroup: {type: 'users', operation: 'create'},
    delGroup: {type: 'users', operation: 'delete'},
    changePassword: {type: 'users', operation: 'write'},
    httpGet: {type: 'other', operation: 'http'},
    cmdExec: {type: 'other', operation: 'execute'},
    sendTo: {type: 'other', operation: 'sendto'},
    sendToHost: {type: 'other', operation: 'sendto'},
    readDir: {type: 'file', operation: 'list'},
    createFile: {type: 'file', operation: 'create'},
    writeFile: {type: 'file', operation: 'write'},
    readFile: {type: 'file', operation: 'read'},
    deleteFile: {type: 'file', operation: 'delete'},
    authEnabled: {type: '', operation: ''},
    disconnect: {type: '', operation: ''},
    listPermissions: {type: '', operation: ''},
    getUserPermissions: {type: 'object', operation: 'read'}
};

function socketEvents(socket) {

    if (socket.conn.request.sessionID) {
        socket._secure = true;
        socket._sessionID = socket.conn.request.sessionID;
        // Get user for session
        adapter.getSession(socket.conn.request.sessionID, function (obj) {
            if (!obj || !obj.passport) {
                socket._acl.user = '';
                socket.emit('reauthenticate');
            }
        });
    }

    // Enable logging, while some browser is connected
    if (adapter.requireLog) {
        adapter.requireLog(true);
    }

    /*
     *      objects
     */
    socket.on('getObject', function (id, callback) {
        if (updateSession(socket) && checkPermissions(socket, 'getObject', callback, id)) {
            adapter.getForeignObject(id, {user: this._acl.user}, callback);
        }
    });

    socket.on('getObjects', function (callback) {
        if (updateSession(socket) && checkPermissions(socket, 'getObjects', callback)) {
            if (socket._acl &&
                    socket._acl.user !== 'system.user.admin' &&
                    socket._acl.groups.indexOf('system.group.administrator') === -1) {
                var result = {};
                for (var ob in objects) {
                    if (checkObject(ob, socket._acl, 4 /* 'read' */)) {
                        result[ob] = objects[ob];
                    }
                }
                callback(null, result);
            } else {
                callback(null, objects);
            }
        }
    });

    socket.on('getObjectView', function (design, search, params, callback) {
        if (updateSession(socket) && checkPermissions(socket, 'getObjectView', callback, search)) {
            adapter.objects.getObjectView(design, search, params, {user: this._acl.user}, callback);
        }
    });

    socket.on('setObject', function (id, obj, callback) {
        if (updateSession(socket) && checkPermissions(socket, 'setObject', callback, id)) {
            adapter.setForeignObject(id, obj, {user: this._acl.user}, callback);
        }
    });

    socket.on('delObject', function (id, callback) {
        if (updateSession(socket) && checkPermissions(socket, 'delObject', callback, id)) {
            adapter.delForeignObject(id, {user: this._acl.user}, callback);
        }
    });

    socket.on('extendObject', function (id, obj, callback) {
        if (updateSession(socket) && checkPermissions(socket, 'extendObject', callback, id)) {
            adapter.extendForeignObject(id, obj, {user: this._acl.user}, callback);
        }
    });

    socket.on('getHostByIp', function (ip, callback) {
        if (updateSession(socket) && checkPermissions(socket, 'getHostByIp', ip)) {
            adapter.objects.getObjectView('system', 'host', {}, {user: this._acl.user}, function (err, data) {
                if (err) {
                    console.log(err);
                }
                if (data.rows.length) {
                    for (var i = 0; i < data.rows.length; i++) {
                        if (data.rows[i].value.common.hostname === ip) {
                            if (callback) {
                                callback(ip, data.rows[i].value);
                            }
                            return;
                        }
                        if (data.rows[i].value.native.hardware && data.rows[i].value.native.hardware.networkInterfaces) {
                            var net = data.rows[i].value.native.hardware.networkInterfaces;
                            for (var eth in net) {
                                for (var j = 0; j < net[eth].length; j++) {
                                    if (net[eth][j].address === ip) {
                                        if (callback) {
                                            callback(ip, data.rows[i].value);
                                        }
                                        return;
                                    }
                                }
                            }
                        }
                    }
                }

                if (callback) {
                    callback(ip, null);
                }
            });
        }
    });

    /*
     *      states
     */
    socket.on('getStates', function (callback) {
        if (updateSession(socket) && checkPermissions(socket, 'getStates', callback)) {
            callback(null, states);
        }
    });

    socket.on('getState', function (id, callback) {
        if (updateSession(socket) && checkPermissions(socket, 'getState', callback, id)) {
            if (callback) {
                callback(null, states[id]);
            }
        }
    });

    socket.on('setState', function (id, state, callback) {
        if (updateSession(socket) && checkPermissions(socket, 'setState', callback, id)) {
            if (typeof state !== 'object') {
                state = {val: state};
            }

            adapter.setForeignState(id, state, {user: this._acl.user}, function (err, res) {
                if (typeof callback === 'function') {
                    callback(err, res);
                }
            });
        }
    });

    socket.on('delState', function (id, callback) {
        if (updateSession(socket) && checkPermissions(socket, 'delState', callback, id)) {
            adapter.delForeignState(id, {user: this._acl.user}, callback);
        }
    });

    /*
     *      History
     */
    socket.on('getStateHistory', function (id, options, callback) {
        if (updateSession(socket) && checkPermissions(socket, 'getStateHistory', callback)) {
            options.user = this._acl.user;
            options.aggregate = options.aggregate || 'none';
            adapter.getHistory(id, options, callback);
        }
    });
    socket.on('getHistory', function (id, options, callback) {
        if (updateSession(socket) && checkPermissions(socket, 'getStateHistory', callback)) {
            options.user = this._acl.user;
            options.aggregate = options.aggregate || 'none';
            adapter.getHistory(id, options, callback);
        }
    });    /*
     *      user/group
     */
    socket.on('addUser', function (user, pass, callback) {
        if (updateSession(socket) && checkPermissions(socket, 'addUser', callback, user)) {
            addUser(user, pass, {user: this._acl.user}, callback);
        }
    });

    socket.on('delUser', function (user, callback) {
        if (updateSession(socket) && checkPermissions(socket, 'delUser', callback, user)) {
            delUser(user, {user: this._acl.user}, callback);
        }
    });

    socket.on('addGroup', function (group, desc, acl, callback) {
        if (updateSession(socket) && checkPermissions(socket, 'addGroup', callback, group)) {
            addGroup(group, desc, acl, {user: this._acl.user}, callback);
        }
    });

    socket.on('delGroup', function (group, callback) {
        if (updateSession(socket) && checkPermissions(socket, 'delGroup', callback, group)) {
            delGroup(group, {user: this._acl.user}, callback);
        }
    });

    socket.on('changePassword', function (user, pass, callback) {
        if (updateSession(socket)) {
            if (user === socket._acl.user || checkPermissions(socket, 'changePassword', callback, user)) {
                adapter.setPassword(user, pass, {user: this._acl.user}, callback);
            }
        }
    });

    // HTTP
    socket.on('httpGet', function (url, callback) {
        if (updateSession(socket) && checkPermissions(socket, 'httpGet', callback, url)) {
            request(url, callback);
        }
    });

    // commands will be executed on host/controller
    // following response commands are expected: cmdStdout, cmdStderr, cmdExit
    socket.on('cmdExec', function (host, id, cmd, callback) {
        if (updateSession(socket) && checkPermissions(socket, 'cmdExec', callback, cmd)) {
            console.log('cmdExec on ' + host + '(' + id + '): ' + cmd);
            // remember socket for this ID.
            cmdSessions[id] = {socket: socket};
            adapter.sendToHost(host, 'cmdExec', {data: cmd, id: id});
        }
    });

    socket.on('readDir', function (_adapter, path, callback) {
        if (updateSession(socket) && checkPermissions(socket, 'readDir', callback, path)) {
            adapter.readDir(_adapter, path, {user: this._acl.user}, callback);
        }
    });

    socket.on('writeFile', function (_adapter, filename, data, callback) {
        if (updateSession(socket) && checkPermissions(socket, 'writeFile', callback, filename)) {
            adapter.writeFile(_adapter, filename, data, {user: this._acl.user}, callback);
        }
    });

    socket.on('readFile', function (_adapter, filename, callback) {
        if (updateSession(socket) && checkPermissions(socket, 'readFile', callback, filename)) {
            adapter.readFile(_adapter, filename, {user: this._acl.user}, callback);
        }
    });

    socket.on('sendTo', function (adapterInstance, command, message, callback) {
        if (updateSession(socket) && checkPermissions(socket, 'sendTo', callback, command)) {
            adapter.sendTo(adapterInstance, command, message, function (res) {
                if (callback) {
                    setTimeout(function () {
                        callback(res);
                    }, 0);
                }
            });
        }
    });

    socket.on('sendToHost', function (host, command, message, callback) {
        // host can answer following commands
        if (updateSession(socket)) {
            if ((command !== 'cmdExec' && command !== 'delLogs' && checkPermissions(socket, 'sendToHost', callback, command)) ||
                    ((command === 'cmdExec' || command === 'delLogs') && checkPermissions(socket, 'cmdExec', callback, command))) {
                adapter.sendToHost(host, command, message, function (res) {
                    if (callback) {
                        setTimeout(function () {
                            callback(res);
                        }, 0);
                    }
                });
            }
        }
    });

    socket.on('authEnabled', function (callback) {
        if (callback) {
            callback(adapter.config.auth, socket._acl.user.replace(/^system\.user\./, ''));
        }
    });

    socket.on('disconnect', function () {
        // Disable logging if no one browser is connected
        if (adapter.requireLog) {
            adapter.requireLog(!!webServer.io.sockets.sockets.length);
        }
    });

    socket.on('listPermissions', function (callback) {
        if (updateSession(socket)) {
            if (callback) {
                callback(commandsPermissions);
            }
        }
    });

    socket.on('getUserPermissions', function (callback) {
        if (updateSession(socket) && checkPermissions(socket, 'getUserPermissions', callback)) {
            if (callback) {
                callback(null, socket._acl);
            }
        }
    });

    socket.on('eventsThreshold', function (isActive) {
        if (!isActive) {
            disableEventThreshold(true);
        } else {
            enableEventThreshold();
        }
    });
}

function onAuthorizeSuccess(data, accept) {
    adapter.log.info('successful connection to socket.io from ' + data.connection.remoteAddress);
    //adapter.log.info(JSON.stringify(data));

    accept();
}

function onAuthorizeFail(data, message, error, accept) {
    if (error) {
        adapter.log.error('failed connection to socket.io from ' + data.connection.remoteAddress + ':', message);
    }

    if (error) {
        accept(new Error(message));
    } else {
        accept('failed connection to socket.io: ' + message);//null, false);
    }
    // this error will be sent to the user as a special error-package
    // see: http://socket.io/docs/client-api/#socket > error-object
}

// read repository information from active repository
function updateRegister() {
    adapter.log.info('Request actual repository...');
    adapter.getForeignObject('system.config', function (err, data) {
        if (err) {
            console.log(err);
        }
        if (data && data.common) {
            adapter.sendToHost(adapter.host, 'getRepository', {
                repo: data.common.activeRepo,
                update: true
            }, function (_repository) {
                if (_repository === 'permissionError') {
                    adapter.log.error('May not read "getRepository"');
                } else {
                    adapter.log.info('Repository received successfully.');
                    webServer.io.sockets.emit('repoUpdated');
                }
            });
        }
    });
}